"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const URI_1 = require("./URI");
const merge = require("lodash.merge");
exports.DEFAULT_EYEGLASS_COMPAT = "^2.0";
/* eslint-disable-next-line no-unused-vars */
class default_1 {
    constructor(options) {
        let config = getSassOptions(options);
        this.eyeglass = config.eyeglass; // this makes the compiler happy.
        merge(this, config);
    }
}
exports.default = default_1;
function includePathsFromEnv() {
    return normalizeIncludePaths(process.env.SASS_PATH, process.cwd());
}
function forbidEyeglassOptionsFromSassOptions(sassOptions, eyeglassOptions) {
    // migrates the following properties from sassOptions to eyeglassOptions
    const forbiddenOptions = ["root", "cacheDir", "buildDir", "httpRoot", "strictModuleVersions"];
    forbiddenOptions.forEach(function (option) {
        if (eyeglassOptions[option] === undefined && sassOptions[option] !== undefined) {
            throw new Error(["`" + option + "` must be passed into the eyeglass options rather than the sass options:",
                "var options = eyeglass({",
                "  /* sassOptions */",
                "  ...",
                "  eyeglass: {",
                "    " + option + ": ...",
                "  }",
                "});"
            ].join("\n  "));
        }
    });
}
function forbidAssetOption(sassOptions, eyeglassOptions, fromOption, toOption) {
    if ((eyeglassOptions.assets === undefined ||
        (eyeglassOptions.assets && eyeglassOptions.assets[toOption] === undefined)) &&
        sassOptions[fromOption] !== undefined) {
        throw new Error([`\`${fromOption}\` has been renamed to \`${toOption}\` and must be passed into the eyeglass asset options rather than the sass options:`,
            "var options = eyeglass({",
            "  /* sassOptions */",
            "  ...",
            "  eyeglass: {",
            "    assets: {",
            `      ${toOption}: ...`,
            "    }",
            "  }",
            "});"
        ].join("\n  "));
    }
}
function forbidAssetOptionsFromSassOptions(sassOptions, eyeglassOptions) {
    // errors on the following legacy properties if passed into sassOptions instead of eyeglassOptions
    forbidAssetOption(sassOptions, eyeglassOptions, "assetsHttpPrefix", "httpPrefix");
    forbidAssetOption(sassOptions, eyeglassOptions, "assetsRelativeTo", "relativeTo");
}
function defaultSassOptions(options) {
    defaultValue(options, "includePaths", () => includePathsFromEnv());
    return options;
}
function requireSass() {
    let sass;
    try {
        sass = require("node-sass");
    }
    catch (e) {
        try {
            sass = require("sass");
        }
        catch (e) {
            throw new Error("A sass engine was not provided and neither `sass` nor `node-sass` were found in the current project.");
        }
    }
    return sass;
}
function resolveConfig(options) {
    // default root dir
    defaultValue(options, "root", () => process.cwd());
    // default cache dir
    defaultValue(options, "cacheDir", () => path.join(options.root, ".eyeglass_cache"));
    // default engines
    defaultValue(options, "engines", () => { return {}; });
    defaultValue(options.engines, "sass", () => requireSass());
    // default assets
    defaultValue(options, "assets", () => { return {}; });
    // default httpRoot
    defaultValue(options, "httpRoot", () => "/");
    // default enableImportOnce
    defaultValue(options, "enableImportOnce", () => true);
    // use global module caching by default
    defaultValue(options, "useGlobalModuleCache", () => true);
    // There's no eyeglass module API changes in eyeglass 2.x so we default to silencing these warnings.
    defaultValue(options, "assertEyeglassCompatibility", () => exports.DEFAULT_EYEGLASS_COMPAT);
    // Use a simple cache that just lasts for this one file if no buildCache is provided.
    defaultValue(options, "buildCache", () => new Map());
    // Strict dependency checks are enabled by default.
    defaultValue(options, "disableStrictDependencyCheck", () => false);
    options.fsSandbox = normalizeFsSandbox(options.fsSandbox, options.root);
    return options;
}
exports.resolveConfig = resolveConfig;
function normalizeFsSandbox(sandboxOption, root) {
    let fsSandbox;
    if (typeof sandboxOption === "undefined") {
        // default to no fs access
        fsSandbox = [];
    }
    else if (sandboxOption === true) {
        // support simple enabling of the sandbox.
        fsSandbox = [root];
    }
    else if (typeof sandboxOption === "string") {
        // support simple strings instead of requiring a list for even a single dir.
        fsSandbox = [sandboxOption];
    }
    else {
        fsSandbox = sandboxOption;
    }
    return fsSandbox;
}
function normalizeIncludePaths(includePaths, baseDir) {
    if (!includePaths) {
        return [];
    }
    // in some cases includePaths is a path delimited string
    if (typeof includePaths === "string") {
        includePaths = includePaths.split(path.delimiter);
    }
    // filter out empty paths
    includePaths = includePaths.filter((dir) => !!dir);
    // make all relative include paths absolute
    return includePaths.map((dir) => path.resolve(baseDir, URI_1.URI.system(dir)));
}
function normalizeSassOptions(sassOptions, eyeglassOptions) {
    sassOptions.includePaths = normalizeIncludePaths(sassOptions.includePaths, eyeglassOptions.root);
    return Object.assign(sassOptions, { eyeglass: eyeglassOptions });
}
const FORBIDDEN_OPTIONS = new Set([
    "root",
    "httpRoot",
    "cacheDir",
    "buildDir",
    "strictModuleVersions",
    "assetsHttpPrefix",
    "assetsRelativeTo",
]);
function hasForbiddenOptions(options) {
    for (let key in options) {
        if (FORBIDDEN_OPTIONS.has(key)) {
            return true;
        }
    }
    return false;
}
function getSassOptions(options) {
    let sassOptions = options || {};
    let eyeglassOptions = {};
    merge(eyeglassOptions, sassOptions.eyeglass);
    // determine whether or not we should normalize URI path separators
    // @see URI
    if (eyeglassOptions.normalizePaths !== undefined) {
        // TODO: make the code read the config from options which is defaulted from the env var
        process.env.EYEGLASS_NORMALIZE_PATHS = `${eyeglassOptions.normalizePaths}`;
    }
    if (hasForbiddenOptions(sassOptions)) {
        // forbid legacy eyeglassOptions within sassOptions
        forbidEyeglassOptionsFromSassOptions(sassOptions, eyeglassOptions);
        forbidAssetOptionsFromSassOptions(sassOptions, eyeglassOptions);
    }
    defaultSassOptions(sassOptions);
    resolveConfig(eyeglassOptions);
    return normalizeSassOptions(sassOptions, resolveConfig(eyeglassOptions));
}
function defaultValue(obj, key, value) {
    if (obj[key] === undefined) {
        obj[key] = value();
    }
}
//# sourceMappingURL=Options.js.map